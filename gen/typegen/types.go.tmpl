package {{.Package}}

{{template "header" .}}

import (
{{- if .NeedFmt}}
	"fmt"
{{- end}}
{{- if .NeedJSON}}
	"encoding/json"
{{- end}}
)
{{range .Types}}
// {{.Comment}}
type {{.Name}} struct {
{{- range .Fields}}
	// {{.Comment}}
	{{.Name}} {{.Type}} {{.JSONTag}}
{{end -}}
}
{{end}}
{{- if .UnionTypes}}
// UnknownVariant stores data for unknown union variants.
// This provides forward compatibility when new variants are added to the API.
type UnknownVariant struct {
	Type string
	Data json.RawMessage
}
{{- end}}
{{- range $u := .UnionTypes}}
// {{$u.DiscriminatorTypeName}} represents the type of {{$u.Name}}.
type {{$u.DiscriminatorTypeName}} int

const (
{{- range $i, $v := $u.Variants}}
{{- if eq $i 0}}
	{{$v.EnumConst}} {{$u.DiscriminatorTypeName}} = iota + 1
{{- else}}
	{{$v.EnumConst}}
{{- end}}
{{- end}}
)

func (v {{$u.DiscriminatorTypeName}}) String() string {
	if v < {{(index $u.Variants 0).EnumConst}} || v > {{(index $u.Variants (sub (len $u.Variants) 1)).EnumConst}} {
		return "unknown"
	}
	return [...]string{
{{- range $u.Variants}}
		"{{.ConstVal}}",
{{- end}}
	}[v-1]
}

func (v {{$u.DiscriminatorTypeName}}) MarshalText() ([]byte, error) {
	return []byte(v.String()), nil
}
{{if $u.CanUnmarshal}}
func (v *{{$u.DiscriminatorTypeName}}) UnmarshalText(b []byte) error {
	switch string(b) {
{{- range $u.Variants}}
	case "{{.ConstVal}}":
		*v = {{.EnumConst}}
{{- end}}
	default:
		*v = 0
	}
	return nil
}
{{- end}}

// {{$u.Comment}}
type {{$u.Name}} struct {
{{- range $u.Variants}}
	{{.FieldName}} *{{.TypeName}}
{{- end}}
	Unknown *UnknownVariant
}
{{if $u.CanUnmarshal}}
func (u *{{$u.Name}}) UnmarshalJSON(data []byte) error {
	var partial struct {
		D string `json:"{{$u.Discriminator}}"`
	}
	if err := json.Unmarshal(data, &partial); err != nil {
		return fmt.Errorf("unmarshal {{$u.Name}}: %w", err)
	}
	switch partial.D {
{{- range $u.Variants}}
	case "{{.ConstVal}}":
		u.{{.FieldName}} = &{{.TypeName}}{}
		return json.Unmarshal(data, u.{{.FieldName}})
{{- end}}
	default:
		u.Unknown = &UnknownVariant{
			Type: partial.D,
			Data: append(json.RawMessage(nil), data...),
		}
		return nil
	}
}
{{- end}}

func (u {{$u.Name}}) MarshalJSON() ([]byte, error) {
	switch {
{{- range $u.Variants}}
	case u.{{.FieldName}} != nil:
		return json.Marshal(struct {
			D string `json:"{{$u.Discriminator}}"`
			*{{.TypeName}}
		}{D: "{{.ConstVal}}", {{.TypeName}}: u.{{.FieldName}}})
{{- end}}
	case u.Unknown != nil:
		return u.Unknown.Data, nil
	default:
		return nil, fmt.Errorf("unknown {{$u.Name}} variant")
	}
}

// {{$u.DiscriminatorMethodName}} returns the discriminator value for this union.
func (u *{{$u.Name}}) {{$u.DiscriminatorMethodName}}() {{$u.DiscriminatorTypeName}} {
	switch {
{{- range $u.Variants}}
	case u.{{.FieldName}} != nil:
		return {{.EnumConst}}
{{- end}}
	default:
		return 0
	}
}

// IsUnknown reports whether this union contains an unknown variant.
// This can happen when the API returns a new variant not yet supported by this library.
func (u *{{$u.Name}}) IsUnknown() bool {
	return u.Unknown != nil
}
{{- if $u.HasConstructors}}
{{range $v := $u.Variants}}
// New{{$v.TypeName}} creates a {{$u.Name}} containing a {{$v.TypeName}}.
{{- if $v.RequiredFields}}
func New{{$v.TypeName}}({{range $i, $f := $v.RequiredFields}}{{if $i}}, {{end}}{{$f.ParamName}} {{$f.GoType}}{{end}}) {{$u.Name}} {
	return {{$u.Name}}{{"{"}}{{$v.FieldName}}: &{{$v.TypeName}}{
{{- range $v.RequiredFields}}
		{{.GoField}}: {{.ParamName}},
{{- end}}
	}{{"}"}}
}
{{- else}}
func New{{$v.TypeName}}() {{$u.Name}} {
	return {{$u.Name}}{{"{"}}{{$v.FieldName}}: &{{$v.TypeName}}{}{{"}"}}
}
{{- end}}
{{end}}
{{- end}}
{{- end}}
{{- range $e := .Enums}}
// {{$e.Name}} represents an enum type.
type {{$e.Name}} {{$e.Underlying}}

const (
	{{$e.Name}}Unknown {{$e.Name}} = iota
{{- range $e.Values}}
	{{.ConstName}}
{{- end}}
)

func (v {{$e.Name}}) String() string {
	if v > {{$e.Name}}Unknown && v <= {{(index $e.Values (sub (len $e.Values) 1)).ConstName}} {
		return [...]string{
{{- range $e.Values}}
			"{{.StringVal}}",
{{- end}}
		}[v-1]
	}
	return "unknown"
}

// IsUnknown reports whether this value is unknown.
func (v {{$e.Name}}) IsUnknown() bool {
	return v == {{$e.Name}}Unknown
}
{{if eq $e.Marshal "json"}}
func (v {{$e.Name}}) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

func (v *{{$e.Name}}) UnmarshalJSON(b []byte) error {
	var s string
	if err := json.Unmarshal(b, &s); err != nil {
		return err
	}
	switch s {
{{- range $e.Values}}
	case "{{.StringVal}}":
		*v = {{.ConstName}}
{{- end}}
	default:
		*v = {{$e.Name}}Unknown
	}
	return nil
}
{{- else if eq $e.Marshal "text"}}
func (v {{$e.Name}}) MarshalText() ([]byte, error) {
	if v != {{$e.Name}}Unknown {
		return []byte(v.String()), nil
	}
	return nil, fmt.Errorf("unknown {{$e.Name}}")
}

func (v *{{$e.Name}}) UnmarshalText(b []byte) error {
	switch string(b) {
{{- range $e.Values}}
	case "{{.StringVal}}":
		*v = {{.ConstName}}
{{- end}}
	default:
		*v = {{$e.Name}}Unknown
	}
	return nil
}
{{- end}}
{{end}}
{{- range $m := .TypeMethods}}
// {{$m.MethodName}} returns the {{$m.ReturnType}} of this {{$m.TypeName}}.
func (v *{{$m.TypeName}}) {{$m.MethodName}}() {{$m.ReturnType}} {
	switch {
{{- range $m.Cases}}
	case {{.Condition}}:
		return {{.EnumConst}}
{{- end}}
	default:
		return {{$m.ReturnType}}Unknown
	}
}
{{end}}
{{- range $vc := .VariantConstructors}}
{{- range $v := $vc.Variants}}
// New{{$vc.TypeName}}{{$v.Name}} creates {{$vc.TypeName}}{{if $v.Comment}} {{$v.Comment}}{{end}}.
func New{{$vc.TypeName}}{{$v.Name}}({{$vc.BaseParam}}{{if and $v.Param (not $v.HasDefault)}}, {{$v.Param}}{{end}}) {{$vc.TypeName}} {
	return {{$vc.TypeName}}{
		{{$vc.BaseGoField}}: {{$vc.BaseArg}},
{{- if $v.GoField}}
		{{$v.GoField}}: {{if $v.HasDefault}}{{$v.DefaultValue}}{{else}}{{$v.Arg}}{{end}},
{{- end}}
	}
}
{{end}}
{{- end}}
