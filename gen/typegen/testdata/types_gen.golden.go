package tg

// Code generated by go-tg/gen. DO NOT EDIT.
//
// Telegram Bot API version:
// Release date:
// Spec hash:

import (
	"encoding/json"
	"fmt"
)

// Update this [object] represents an incoming update.
//
// [object]: https://core.telegram.org/bots/api#available-types
type Update struct {
	// The update's unique identifier. This identifier becomes especially handy if you're using [Client.SetWebhook].
	ID int `json:"update_id"`

	// Optional. New incoming [Message].
	Message *Message `json:"message,omitempty"`
}

// WebhookInfo describes the current status of a webhook.
type WebhookInfo struct {
	// Webhook URL.
	URL string `json:"url"`

	// Optional. Unix time for the most recent error.
	LastErrorDate UnixTime `json:"last_error_date,omitempty"`

	// Optional. A list of update types the bot is subscribed to.
	AllowedUpdates []UpdateType `json:"allowed_updates,omitempty"`
}

// User this object represents a Telegram user or bot.
type User struct {
	// Unique identifier for this user or bot.
	ID UserID `json:"id"`

	// True, if this user is a bot.
	IsBot bool `json:"is_bot"`

	// Optional. User's or bot's username.
	Username Username `json:"username,omitempty"`
}

// Message this object represents a message.
type Message struct {
	// Unique message identifier.
	ID int `json:"message_id"`

	// Date the message was sent in Unix time.
	Date UnixTime `json:"date"`

	// Optional. Available sizes of the photo.
	Photo []PhotoSize `json:"photo,omitempty"`

	// Optional. The group has been migrated to a supergroup.
	MigrateToChatID ChatID `json:"migrate_to_chat_id,omitempty"`
}

// ChatPhoto this object represents a chat photo.
type ChatPhoto struct {
	// File identifier of small photo.
	SmallFileID FileID `json:"small_file_id"`

	// File identifier of big photo.
	BigFileID FileID `json:"big_file_id"`
}

// InlineQueryResultMPEG4GIF represents a link to a video animation.
type InlineQueryResultMPEG4GIF struct {
	// A valid URL for the MPEG4 file.
	MPEG4URL string `json:"mpeg4_url"`

	// Optional. Video width.
	MPEG4Width int `json:"mpeg4_width,omitempty"`

	// Optional. Mode for parsing entities in the text.
	TextParseMode ParseMode `json:"text_parse_mode,omitempty"`
}

// PollAnswer this object represents an answer of a user in a non-anonymous poll.
type PollAnswer struct {
	// Unique identifier of the user that answered.
	UserID UserID `json:"user_id"`

	// 0-based identifiers of chosen answer options.
	OptionIDs []int `json:"option_ids"`
}

// LoginURL this object represents a parameter of the inline keyboard button.
type LoginURL struct {
	// An HTTPS URL.
	URL string `json:"url"`

	// Optional. Username of a bot.
	BotUsername Username `json:"bot_username,omitempty"`
}

// InputMediaPhoto represents a photo to be sent.
type InputMediaPhoto struct {
	// File to send. Pass a file_id to send a file that exists on the Telegram servers, pass an HTTP URL, or pass "attach://<file_attach_name>".
	Media FileArg `json:"media"`
}

// InputPaidMediaVideo the paid media to send is a video.
type InputPaidMediaVideo struct {
	// File to send. Pass a file_id to send a file that exists on the Telegram servers, pass an HTTP URL, or pass "attach://<file_attach_name>".
	Media FileArg `json:"media"`

	// Optional. Thumbnail of the file sent; the thumbnail should be in JPEG format. The file must be uploaded using multipart/form-data under the name specified in "attach://<file_attach_name>".
	Thumbnail *InputFile `json:"thumbnail,omitempty"`

	// Optional. Cover for the video. Pass a file_id to send a file that exists on the Telegram servers, pass an HTTP URL, or pass "attach://<file_attach_name>".
	Cover *FileArg `json:"cover,omitempty"`
}

// InputProfilePhotoStatic a static profile photo in the .JPG format.
type InputProfilePhotoStatic struct {
	// The static profile photo. The photo must be uploaded using multipart/form-data under the name specified in "attach://<file_attach_name>".
	Photo InputFile `json:"photo"`
}

// BackgroundFillSolid the background is filled with a solid color.
type BackgroundFillSolid struct {
	// The color of the background fill.
	Color int `json:"color"`
}

// BackgroundFillGradient the background is a gradient fill.
type BackgroundFillGradient struct {
	// Top color of the gradient.
	TopColor int `json:"top_color"`
}

// InputTextMessageContent represents the content of a text message.
type InputTextMessageContent struct {
	// Text of the message to be sent.
	MessageText string `json:"message_text"`

	// Optional. Mode for parsing entities.
	ParseMode ParseMode `json:"parse_mode,omitempty"`
}

// InputLocationMessageContent represents the content of a location message.
type InputLocationMessageContent struct {
	// Latitude of the location.
	Latitude float64 `json:"latitude"`

	// Longitude of the location.
	Longitude float64 `json:"longitude"`
}

// InlineKeyboardMarkup an inline keyboard that appears right next to the message it belongs to.
type InlineKeyboardMarkup struct {
	// Array of button rows.
	InlineKeyboard [][]InlineKeyboardButton `json:"inline_keyboard"`
}

// ReplyKeyboardMarkup a custom keyboard with reply options.
type ReplyKeyboardMarkup struct {
	// Array of button rows.
	Keyboard [][]KeyboardButton `json:"keyboard"`

	// Optional. Resize the keyboard vertically.
	ResizeKeyboard bool `json:"resize_keyboard,omitempty"`

	// Optional. Hide keyboard after use.
	OneTimeKeyboard bool `json:"one_time_keyboard,omitempty"`

	// Optional. Placeholder text.
	InputFieldPlaceholder string `json:"input_field_placeholder,omitempty"`

	// Optional. Show to specific users only.
	Selective bool `json:"selective,omitempty"`
}

// ReplyKeyboardRemove removes the custom keyboard.
type ReplyKeyboardRemove struct {
	// Requests removal of the keyboard.
	RemoveKeyboard bool `json:"remove_keyboard"`

	// Optional. Show to specific users only.
	Selective bool `json:"selective,omitempty"`
}

// ForceReply display a reply interface to the user.
type ForceReply struct {
	// Shows reply interface.
	ForceReply bool `json:"force_reply"`

	// Optional. Placeholder text.
	InputFieldPlaceholder string `json:"input_field_placeholder,omitempty"`

	// Optional. Show to specific users only.
	Selective bool `json:"selective,omitempty"`
}

// InlineQueryResultArticle represents a link to an article.
type InlineQueryResultArticle struct {
	// Unique identifier.
	ID string `json:"id"`

	// Title of the result.
	Title string `json:"title"`

	// Content of the message to be sent.
	InputMessageContent InputMessageContent `json:"input_message_content"`

	// Optional. Inline keyboard attached to the message.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// InlineQueryResultPhoto represents a link to a photo.
type InlineQueryResultPhoto struct {
	// Unique identifier.
	ID string `json:"id"`

	// Optional. Content of the message to be sent.
	InputMessageContent InputMessageContent `json:"input_message_content,omitempty"`
}

// UnknownVariant stores data for unknown union variants.
// This provides forward compatibility when new variants are added to the API.
type UnknownVariant struct {
	Type string
	Data json.RawMessage
}

// BackgroundFillType represents the type of BackgroundFill.
type BackgroundFillType int

const (
	BackgroundFillTypeSolid    BackgroundFillType = iota + 1 // "solid"
	BackgroundFillTypeGradient                               // "gradient"
)

func (v BackgroundFillType) String() string {
	if v < BackgroundFillTypeSolid || v > BackgroundFillTypeGradient {
		return "unknown"
	}
	return [...]string{
		"solid",
		"gradient",
	}[v-1]
}

func (v BackgroundFillType) MarshalText() ([]byte, error) {
	return []byte(v.String()), nil
}

func (v *BackgroundFillType) UnmarshalText(b []byte) error {
	switch string(b) {
	case "solid":
		*v = BackgroundFillTypeSolid
	case "gradient":
		*v = BackgroundFillTypeGradient
	default:
		*v = 0
	}
	return nil
}

// BackgroundFill this object describes the background fill.
type BackgroundFill struct {
	Solid    *BackgroundFillSolid
	Gradient *BackgroundFillGradient
	Unknown  *UnknownVariant
}

func (u *BackgroundFill) UnmarshalJSON(data []byte) error {
	var partial struct {
		D string `json:"type"`
	}
	if err := json.Unmarshal(data, &partial); err != nil {
		return fmt.Errorf("unmarshal BackgroundFill: %w", err)
	}
	switch partial.D {
	case "solid":
		u.Solid = &BackgroundFillSolid{}
		return json.Unmarshal(data, u.Solid)
	case "gradient":
		u.Gradient = &BackgroundFillGradient{}
		return json.Unmarshal(data, u.Gradient)
	default:
		u.Unknown = &UnknownVariant{
			Type: partial.D,
			Data: append(json.RawMessage(nil), data...),
		}
		return nil
	}
}

func (u BackgroundFill) MarshalJSON() ([]byte, error) {
	switch {
	case u.Solid != nil:
		return json.Marshal(struct {
			D string `json:"type"`
			*BackgroundFillSolid
		}{D: "solid", BackgroundFillSolid: u.Solid})
	case u.Gradient != nil:
		return json.Marshal(struct {
			D string `json:"type"`
			*BackgroundFillGradient
		}{D: "gradient", BackgroundFillGradient: u.Gradient})
	case u.Unknown != nil:
		return u.Unknown.Data, nil
	default:
		return nil, fmt.Errorf("unknown BackgroundFill variant")
	}
}

// Type returns the discriminator value for this union.
func (u *BackgroundFill) Type() BackgroundFillType {
	switch {
	case u.Solid != nil:
		return BackgroundFillTypeSolid
	case u.Gradient != nil:
		return BackgroundFillTypeGradient
	default:
		return 0
	}
}

// IsUnknown reports whether this union contains an unknown variant.
// This can happen when the API returns a new variant not yet supported by this library.
func (u *BackgroundFill) IsUnknown() bool {
	return u.Unknown != nil
}

// NewBackgroundFillSolid creates a new BackgroundFillSolid.
func NewBackgroundFillSolid(color int) *BackgroundFillSolid {
	return &BackgroundFillSolid{
		Color: color,
	}
}

// AsBackgroundFill wraps the variant into a BackgroundFill union.
func (v *BackgroundFillSolid) AsBackgroundFill() BackgroundFill {
	return BackgroundFill{Solid: v}
}

// NewBackgroundFillGradient creates a new BackgroundFillGradient.
func NewBackgroundFillGradient(topColor int) *BackgroundFillGradient {
	return &BackgroundFillGradient{
		TopColor: topColor,
	}
}

// AsBackgroundFill wraps the variant into a BackgroundFill union.
func (v *BackgroundFillGradient) AsBackgroundFill() BackgroundFill {
	return BackgroundFill{Gradient: v}
}

// BackgroundFillClass is an interface for types that can be used as [BackgroundFill].
//
// Known implementations:
//   - [*BackgroundFillSolid]
//   - [*BackgroundFillGradient]
//   - [BackgroundFill]
type BackgroundFillClass interface {
	AsBackgroundFill() BackgroundFill
}

// AsBackgroundFill returns the union as-is, implementing BackgroundFillClass.
func (u BackgroundFill) AsBackgroundFill() BackgroundFill {
	return u
}

// BackgroundFillOf converts BackgroundFillClass arguments to a slice of BackgroundFill.
func BackgroundFillOf(values ...BackgroundFillClass) []BackgroundFill {
	result := make([]BackgroundFill, len(values))
	for i, v := range values {
		result[i] = v.AsBackgroundFill()
	}
	return result
}

// MessageOrigin this object describes the origin of a message.
//
// Known implementations:
//   - [MessageOriginUser]
//   - [MessageOriginChat]
type MessageOrigin interface {
	isMessageOrigin()
}

func (v MessageOriginUser) isMessageOrigin() {}
func (v MessageOriginChat) isMessageOrigin() {}

// InputMessageContent this object represents the content of a message to be sent as a result of an inline query.
//
// Known implementations:
//   - [InputTextMessageContent]
//   - [InputLocationMessageContent]
type InputMessageContent interface {
	isInputMessageContent()
}

func (v InputTextMessageContent) isInputMessageContent()     {}
func (v InputLocationMessageContent) isInputMessageContent() {}

// NewInputTextMessageContent creates a new InputTextMessageContent.
func NewInputTextMessageContent(messageText string) *InputTextMessageContent {
	return &InputTextMessageContent{
		MessageText: messageText,
	}
}

// NewInputLocationMessageContent creates a new InputLocationMessageContent.
func NewInputLocationMessageContent(latitude float64, longitude float64) InputLocationMessageContent {
	return InputLocationMessageContent{
		Latitude:  latitude,
		Longitude: longitude,
	}
}

// ReplyMarkup is a marker interface for ReplyMarkup variants.
//
// Known implementations:
//   - [InlineKeyboardMarkup]
//   - [ReplyKeyboardMarkup]
//   - [ReplyKeyboardRemove]
//   - [ForceReply]
type ReplyMarkup interface {
	isReplyMarkup()
}

func (v InlineKeyboardMarkup) isReplyMarkup() {}
func (v ReplyKeyboardMarkup) isReplyMarkup()  {}
func (v ReplyKeyboardRemove) isReplyMarkup()  {}
func (v ForceReply) isReplyMarkup()           {}

// NewInlineKeyboardMarkup creates a new InlineKeyboardMarkup.
func NewInlineKeyboardMarkup(inlineKeyboard ...[]InlineKeyboardButton) InlineKeyboardMarkup {
	return InlineKeyboardMarkup{
		InlineKeyboard: inlineKeyboard,
	}
}

// NewReplyKeyboardMarkup creates a new ReplyKeyboardMarkup.
func NewReplyKeyboardMarkup(keyboard ...[]KeyboardButton) *ReplyKeyboardMarkup {
	return &ReplyKeyboardMarkup{
		Keyboard: keyboard,
	}
}

// NewReplyKeyboardRemove creates a new ReplyKeyboardRemove.
func NewReplyKeyboardRemove() *ReplyKeyboardRemove {
	return &ReplyKeyboardRemove{
		RemoveKeyboard: true,
	}
}

// NewForceReply creates a new ForceReply.
func NewForceReply() *ForceReply {
	return &ForceReply{
		ForceReply: true,
	}
}

// WithParseMode sets the ParseMode field.
func (v *InputTextMessageContent) WithParseMode(parseMode ParseMode) *InputTextMessageContent {
	v.ParseMode = parseMode
	return v
}

// WithResizeKeyboard sets the ResizeKeyboard field.
func (v *ReplyKeyboardMarkup) WithResizeKeyboard() *ReplyKeyboardMarkup {
	v.ResizeKeyboard = true
	return v
}

// WithOneTimeKeyboard sets the OneTimeKeyboard field.
func (v *ReplyKeyboardMarkup) WithOneTimeKeyboard() *ReplyKeyboardMarkup {
	v.OneTimeKeyboard = true
	return v
}

// WithInputFieldPlaceholder sets the InputFieldPlaceholder field.
func (v *ReplyKeyboardMarkup) WithInputFieldPlaceholder(inputFieldPlaceholder string) *ReplyKeyboardMarkup {
	v.InputFieldPlaceholder = inputFieldPlaceholder
	return v
}

// WithSelective sets the Selective field.
func (v *ReplyKeyboardMarkup) WithSelective() *ReplyKeyboardMarkup {
	v.Selective = true
	return v
}

// WithSelective sets the Selective field.
func (v *ReplyKeyboardRemove) WithSelective() *ReplyKeyboardRemove {
	v.Selective = true
	return v
}

// WithInputFieldPlaceholder sets the InputFieldPlaceholder field.
func (v *ForceReply) WithInputFieldPlaceholder(inputFieldPlaceholder string) *ForceReply {
	v.InputFieldPlaceholder = inputFieldPlaceholder
	return v
}

// WithSelective sets the Selective field.
func (v *ForceReply) WithSelective() *ForceReply {
	v.Selective = true
	return v
}
